import MD5 from 'crypto-js/md5';
import ServerError from './ServerError';
import {CODE, CODE_TYPE, CODE_EVENT} from './ResponseCode';

export async function toAsync(promise) {
    const response = await promise;
    if (response.ok) {
        let res = await response.json();
        let rCode = CODE[res.Code];
        if (rCode) {
            if (rCode.type === CODE_TYPE.SUCCESS) {
                return res;
            } else {
                handleEvent(rCode.event || CODE_EVENT[rCode.type], res);
                let message = rCode.message || res.Desc;
                if (typeof message === 'function') {
                    message = message(res);
                }
                throw new ServerError(res.Code, message);
            }
        } else {
            throw new ServerError(res.Code, res.Desc);
        }
    } else {
        throw new ServerError(response.status || 0, `fetch "${response.url}" : ${response.statusText || response.message || 'error'}`);
    }
}

function handleEvent(event, res) {
    let e = event;
    if (typeof event === 'object') {
        e = event.event;
    }
    if (typeof e === 'function') {
        e(res);
    }
}

function trimp(param) {
    let type = typeof param;
    if (type === 'string') {
        let p_trim = param.trim();
        // 临时代码 全角替换半角 start
        const len = p_trim.length;
        if ((len === 11 || len === 16 || len === 18 || len === 19)
            && p_trim.match(/[\uff00-\uffff]/)) {
            let p_trim_arr = p_trim.split('');
            let p_trim_res = '';
            for (const ch of p_trim_arr) {
                const ch_code = ch.charCodeAt();
                if (ch_code > 65280 && ch_code < 65375) {
                    p_trim_res += String.fromCharCode(ch_code - 65248);
                } else {
                    p_trim_res += ch;
                }
            }
            // console.log('全角转化', p_trim, p_trim_res);
            p_trim = p_trim_res;
        }
        // 临时代码 全角替换半角 end
        return p_trim;
    } else if (type === 'object' || type === 'array') {
        for (let key in param) {
            param[key] = trimp(param[key]);
        }
        return param;
    } else {
        return param;
    }
}

export class RequestTransfer {

    constructor(AppSetting, authInfo) {
        this.AppSetting = AppSetting || {};
        this.authInfo = authInfo || {};
    }

    set config(options) {
        options && Object.entries(options).forEach(([k, v]) => {
            if (this[k]) {
                this[k] = Object.assign(this[k], v);
            }
        });
    }

    getRequestInit(req) {
        return {
            method: 'POST',
            headers: {"Content-Type": "application/json; charset=UTF-8"},
            body: this.transfer(req)
        };
    }

    getSign(dataStr, TimeStampStr) {
        if (typeof dataStr !== 'string' || typeof TimeStampStr !== 'string') {
            throw Error('Arguments type must be string. dataStr & timeStampStrt');
        }
        return MD5(this.AppSetting.AppKey + TimeStampStr + dataStr + this.AppSetting.AppSecret, 32).toString();
    }

    transfer(params) {
        const dataStr = JSON.stringify(trimp(params || {}));
        const nowTmp = Math.round((new Date()).getTime() / 1000);
        const Uid = this.AppSetting.UidKey ? this.authInfo[this.AppSetting.UidKey] : 0;
        return JSON.stringify({
            AppVer: this.AppSetting.AppVersion,
            TimeStamp: nowTmp,
            Lang: this.AppSetting.Lang || 'CN',
            DeviceName: this.AppSetting.DeviceName || '',
            DeviceType: this.AppSetting.DeviceType || 'web',
            Token: this.authInfo.Token || '',
            Uid: Uid || 0,
            AppKey: this.AppSetting.AppKey,
            Sign: this.getSign(dataStr, nowTmp.toString()),
            Data: dataStr
        });
    }
}